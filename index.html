<!doctype html>
<!--[if lt IE 7]>
<html class="no-js lt-ie9 lt-ie8 lt-ie7">
<![endif]-->
<!--[if IE 7]>
<html class="no-js lt-ie9 lt-ie8">
<![endif]-->
<!--[if IE 8]>
<html class="no-js lt-ie9">
<![endif]-->
<!--[if gt IE 8]><!-->
<html xmlns="http://www.w3.org/1999/xhtml" class="no-js">
<!--<![endif]-->
  <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <meta property="og:site_name" content="bloomberg.github.io"/>
  <meta property="og:type" content="article"/>

  <meta name="twitter:card" content="summary_large_image"/>

  <!-- meta tags for this project -->
  <!-- SEO headline rewritten to accomodate keywords -->
  <title>wsk</title>

  <!-- What is the main headline? -->
  <meta property="og:title" content="wsk">
  <!-- What is the share-able image -->
  <!-- Image aspect ratio: 1.91:1 Image Dimensions: 1200x630px -->
  <meta property="og:image" content="https://bloomberg.github.io/wsk/img/wsk.gif"/>
  <!-- What shows up in Facebook -->
  <meta property="og:description" content="wsk, a straightforward and maintainable build system from the Bloomberg Graphics team."/>
  <!-- What shows up in search engines -->
  <meta name="description" content="wsk, a straightforward and maintainable build system from the Bloomberg Graphics team.">
  <!-- Some keywords if you want -->
  <meta name="keywords" content="wsk, wsk-notify, bloomberg graphics, build system, wsk build system, javascript console notifications"/>
  <!-- The full link to this graphic -->
  <!-- If you're using https, change these urls -->
  <meta property="og:url" content="https://bloomberg.github.io/wsk/"/>

  <!-- Twitter -->
  <meta name="twitter:site" content="@bbgvisualdata"/>
  <!-- What is the tweet / share statement? -->
  <meta name="twitter:title" content="wsk — The lightweight, maintainable build system">
  <!-- What is the tweet / share statement? -->
  <meta name="twitter:image" content="https://bloomberg.github.io/wsk/img/wsk.gif">

  <link rel="apple-touch-icon" sizes="57x57" href="img/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="img/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="img/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="img/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="img/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="img/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="img/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="img/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="img/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="img/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="img/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="img/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="img/favicon/favicon-16x16.png">
  <link rel="manifest" href="img/favicon/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="img/favicon/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="shortcut icon" type="image/x-icon" href="img/favicon.ico">

  <!-- Styles for this project -->
  <link rel="stylesheet" type="text/css" href="css/styles.css"/>

  </head>
  <body>
      

  <main>

    <div class="content">
      <div class="splash">
        <h1 id="wsk"><a class="anchor-link" href="#wsk"></a> wsk</h1><a href="https://travis-ci.org/bloomberg/wsk"><img src="https://img.shields.io/travis/bloomberg/wsk/master.svg?style=flat-square" alt="Build status"></a>
<a href="https://coveralls.io/github/bloomberg/wsk?branch=master"><img src="https://img.shields.io/coveralls/github/bloomberg/wsk/master.svg?style=flat-square" alt="Coverage"></a>
<a href="https://www.npmjs.com/package/wsk"><img src="https://img.shields.io/npm/v/wsk.svg?style=flat-square" alt="npm version"></a>
<a href="https://github.com/Flet/semistandard"><img src="https://img.shields.io/badge/code%20style-semistandard-00b9e7.svg?style=flat-square" alt="js-semistandard-style"></a>
<blockquote>
<p>A straightforward and maintainable build system from the <a href="https://www.bloomberg.com/graphics">Bloomberg Graphics team</a>.</p>
</blockquote>
      </div>
      <div class="guide">
        <div class="scroll-section"><h2 id="installation"><a class="anchor-link" href="#installation">#</a> Installation</h2><pre><code>npm install --save wsk
</code></pre>
</div><div class="scroll-section"><h2 id="about"><a class="anchor-link" href="#about">#</a> About</h2><p>wsk is a small JavaScript library combined with a recommended architecture for creating a reliable build system. It was built by the Bloomberg Graphics and Data Journalism team as an open-ended and maintainable solution to building projects. It has allowed us to democratize our build system—allowing the greatest number of people the ability to modify it if need be—and delivers the right level of notification in order to quickly diagnose any JavaScript, CSS or templating errors that may arise.</p>
<p><strong><a href="https://bloomberg.github.io/wsk.example">See an example project</a></strong></p>
</div><div class="scroll-section"><h3 id="built-in-functionality"><a class="anchor-link" href="#built-in-functionality">##</a> Built-in Functionality</h3><p><img src="img/wsk-watcher.png" alt="wsk layout"></p>
<p>At its core, wsk provides a specification around the <a href="https://github.com/paulmillr/chokidar">chokidar</a> for watching one or more files and declaring scripts to run when those files are created, modified or deleted. The scripts that run are designed to be as arbitrary as possible so that wsk does not lock you into a plugin ecosystem that might get stale or you might want to work outside for a given task.</p>
<p>This design optimizes for maintainability and clarity, without depending on intermediate wrapper plugins.</p>
</div><div class="scroll-section"><h3 id="architecture"><a class="anchor-link" href="#architecture">##</a> Architecture</h3><p>Since wsk as few built-in opinions, you can configure it multiple ways. Here is one way based on some common build patterns.</p>
<p><img src="img/wsk-layout.png" alt="wsk layout"></p>
<p>Generally, a build system has two modes of operation: <strong>development</strong> and <strong>production</strong>.</p>
<p>In <strong>development</strong> mode, you want to be watching a set of files and when one of them changes, that file should rebuild.</p>
<p>In <strong>production</strong> mode, you&#39;re acting across a group of files and building them all.</p>
<p>In this setup, <code>npm run</code> commands in <code>package.json</code> will initialize watchers when in development mode and build files directly in production mode.</p>
<p>It leverages npm scripts to orchestrate these commands and bash to handle parallelism to avoid reinventing the wheel.</p>
<p>See how this system looks in production by looking at <a href="https://www.github.com/bloomberg/wsk.example">the example project&#39;s source</a>.</p>
</div><div class="scroll-section"><h2 id="faq"><a class="anchor-link" href="#faq">#</a> FAQ</h2></div><div class="scroll-section"><h3 id="how-is-it-different"><a class="anchor-link" href="#how-is-it-different">##</a> How is it different?</h3><p>Its main differences are that it:</p>
<ol>
<li>recommends project creators use libraries directly through the wsk task file pattern instead of relying on intermediate plugins such as you would in Gulp (e.g. <code>gulp-sass</code>, <code>gulp-live-server</code>).</li>
<li>recommends npm scripts as a consistent and powerful way to orchestrate these task files as opposed to building a task runner into your build system.</li>
<li>notifies the user of granular events with pertinent information. With wsk, it&#39;s clear how your task processes are interacting with each other and is verbose about any errors.</li>
</ol>
</div><div class="scroll-section"><h3 id="what-are-the-advantages"><a class="anchor-link" href="#what-are-the-advantages">##</a> What are the advantages?</h3><p>Through a combination of the above factors, wsk removes itself as much as possible from the list of things that can go wrong during your build. If your build step has an error, you&#39;ll have fewer layers to debug and its notifications will help you pinpoint the error more directly.</p>
<p>The code inside of wsk concerns itself with the boring plumbing of watching files and then firing off task events when they&#39;ve changed. By keeping the core library small and using existing JavaScript and npm patterns, it keeps you focused on what you want your build to do instead of learning wsk-specific concepts.</p>
</div><div class="scroll-section"><h3 id="why-not-gulp"><a class="anchor-link" href="#why-not-gulp">##</a> Why not Gulp?</h3><p>Gulp can be great in getting you up to speed creating a project by leveraging the community of plugin developers. This can also be problematic, however, since sometimes plugins aren&#39;t well maintained or only work with a certain version of the target library. If plugin design switches between major versions, you might also have to redo a large portion of your system.</p>
<p>This situation can be tricky to debug unless you&#39;re fairly familiar with Gulp infrastructure. Having these plugins in your node_modules folder, where they might be written in a different coding styles, also makes it harder for anyone to jump in, diagnose and fix the problem. In some cases, you might have to fork the plugin if the maintainer isn&#39;t quick to respond.</p>
<p>Gulp also requires the use of advanced concepts such as streams and vinyl objects. Getting up to speed on the ins and outs of these technologies is non-trivial and introduces cognitive load that could be better spent elsewhere.</p>
<p>Using libraries directly in a wsk task file pattern means you aren&#39;t depending on a wrapper plugin of dubious provenance. wsk tasks files are vanilla JavaScript that do not depend on any more advanced programming concepts than event names, file paths and functions.</p>
</div><div class="scroll-section"><h3 id="arent-streams-useful-though"><a class="anchor-link" href="#arent-streams-useful-though">##</a> Aren&#39;t streams useful, though?</h3><p>Nothing in wsk precludes you from writing your tasks to use streams if you feel it is a better way of reading and writing files. Why Gulp uses streams is worth discussing, though, if you want to decide whether to use them in your project.</p>
<p>Gulp uses streams to avoid the sin of its immediate predecessor, Grunt, of reading and writing intermediate files to disk, which caused very slow builds.</p>
<p>As a solution, Gulp streams are a contract between itself and plugins for handing off files from transformation to transformation. By having a way to pass a file in memory, Gulp is much faster.</p>
<p>The key here is that streams are a means to an end, not the end in itself. As the next section discusses, for most of the file I/O you&#39;re doing in a build system, you&#39;re not getting a big advantage with streams.</p>
</div><div class="scroll-section"><h3 id="but-isnt-it-faster-to-load-a-file-with-a-stream"><a class="anchor-link" href="#but-isnt-it-faster-to-load-a-file-with-a-stream">##</a> But isn&#39;t it faster to load a file with a stream?</h3><p>In some cases. It seems that for files <a href="https://medium.com/@dalaidunc/fs-readfile-vs-streams-to-read-text-files-in-node-js-5dd0710c80ea">over 10mb this is the case</a>. But files in your build will be much smaller than that so you&#39;re not often getting the efficiencies streams would bring.</p>
<p>if you&#39;re loading json files or a similar format that must be read in completely before the transformation can begin, you can&#39;t take advantage of a stream&#39;s ability to start acting on the file before its fully loaded. In addition, if you&#39;re using a Gulp plugin, there&#39;s no guarantee that the plugin has actually implemented streams in a way that you&#39;re getting the performance benefit unless you do a full code review.</p>
<p>HTML templating is a good example of how you&#39;d have to optimize far down the rabbit hole to get the full benefit (again, your files would still have to be very large). Let&#39;s say you are loading in an HTML file that pulls in other HTML partials. Unless those partials are also coming in as streams, the bulk of your markup compilation is most likely using <code>fs.readFile</code>.</p>
<p>This is also the case with Rollup, which uses <code>fs.readFileSync</code> in <a href="https://github.com/rollup/rollup/blob/9e481d890d333210de3364379b0b1004ee2169f7/src/watch/fileWatchers.js#L69">parts of its code</a> for example.</p>
<p>gulp-sass, a widely used plugin with over a million monthly downloads <a href="https://github.com/dlmanning/gulp-sass/blob/035b759f51713e44f7c280f43cd1176e84b0f124/index.js#L26">explicitly doesn&#39;t support streaming</a> since its underlying node-sass library requires either <a href="https://github.com/sass/node-sass/blob/e934a55d5a0433e8e1d483a485c4717c9a416b6c/README.md#file">a file path or a string</a>.</p>
<p>Wrapping these libraries in a Gulp plugin doesn&#39;t get you around their own internal functionality.</p>
</div><div class="scroll-section"><h3 id="how-are-task-files-different-from-plugins"><a class="anchor-link" href="#how-are-task-files-different-from-plugins">##</a> How are task files different from plugins?</h3><p>One of the design ideas we&#39;ve implemented in these example projects is that task files—what would be plugins in a Gulp setup—are committed into each project instead of hosted on npm and required as modules. While this is not mandated by wsk, it has been a helpful practice for our team because it helps avoid some of the issues we&#39;ve seen with the plugin ecosystems. It might not make sense for your setup and there are some drawbacks, so it&#39;s worth discussing.</p>
<p>A convenience of plugins is that it&#39;s easier when someone has done the work for you, assuming the work they&#39;ve done is what you&#39;re looking for.</p>
<p>However, canonical plugins can get bloated with complex features you don&#39;t need. Or, they become too advanced and incompatible with your version of Node. Also, you might have to wait for a plugin update to support the latest version.</p>
<p>Looking at the library and writing something as close to the &quot;Hello, World&quot; example as possible has been a sensible guideline for us.</p>
<p>There&#39;s no reason why you can&#39;t write your own Gulp plugins this way, of course. In that scenario, however, your team needs to feel comfortable with Gulp conventions such as Node streams and vinyl objects, so there&#39;s larger investment in training. wsk is vanilla JavaScript/Node with no extra learning necessary.</p>
<p>As background, our stories are independent projects that are built from a common scaffold. Committing each task file into the project gives the creator flexibility to make changes without having to 1) make a fork or create a pull request on a registered plugin 2) verify the change won&#39;t break previous projects that published without a problem 3) bump the version 4) change the package.json and reinstall. If a change is useful for future projects, such as a bug fix or an API update, we update the project scaffold. Those are rarer events and can happen after the story&#39;s deadline.</p>
<p>wsk itself has very few baked in opinions about how plugins/task files must work, leaving possibilities open.</p>
<p>So what <em>should</em> a wsk ecosystem look like?</p>
<p>For now, let&#39;s say it works more like a template or cookbook where you look at an existing example to get going and implement that pattern in your project with any necessary changes. The <a href="https://github.com/bloomberg/wsk.example/tree/master/build/tasks">wsk example project</a> has templates for <a href="https://browsersync.io/">BrowserSync</a>, HTML building with <a href="https://underscorejs.org#template">Underscore.js templates</a>, <a href="https://rollupjs.org/">Rollup</a>, <a href="https://stylus-lang.com/">Stylus</a>, <a href="https://github.com/sass/node-sass">node-sass</a> and static file copying.</p>
</div><div class="scroll-section"><h3 id="why-not-webpack"><a class="anchor-link" href="#why-not-webpack">##</a> Why not Webpack?</h3><p>Architecturally, it&#39;s much higher level than wsk.</p>
<p>Webpack does a lot of really neat stuff but it&#39;s also monolithic; it&#39;s hard to break off just a piece of it or swap in something else. Whereas in Webpack, you give your project over to its way of doing things from the JavaScript to the CSS, wsk is designed to have each task file be easily interchangeable.</p>
</div><div class="scroll-section"><h3 id="why-not-command-line-libraries-in-npm-scripts"><a class="anchor-link" href="#why-not-command-line-libraries-in-npm-scripts">##</a> Why not command-line libraries in npm scripts?</h3><p>JavaScript APIs expose more functionality than their command-line interfaces. Thus making a task file gives you more control than stringing command line arguments into an npm script. Command-line interfaces can make your <code>package.json</code> difficult to read and are tricky to comment and scale. Also, your notifications will all be in different styles at different levels of log specificity, which will confuse the user and make it more difficult to spot errors.</p>
</div><div class="scroll-section"><h3 id="how-did-you-design-wsk"><a class="anchor-link" href="#how-did-you-design-wsk">##</a> How did you design wsk?</h3><p>Check out our <a href="https://github.com/bloomberg/wsk/blob/master/HOW-DID-WE-GET-HERE.md">HOW-DID-WE-GET-HERE.md</a> document to read the illustrated journey.</p>
</div><div class="scroll-section"><h2 id="usage"><a class="anchor-link" href="#usage">#</a> Usage</h2></div><div class="scroll-section"><h3 id="creating-a-watch-file"><a class="anchor-link" href="#creating-a-watch-file">##</a> Creating A Watch File</h3><p>In a wsk project, the idea is you have <strong>files to watch</strong> and <strong>tasks that are run</strong> when certain events happen to those files. You configure this relationship with a watcher file. Here&#39;s an example schema with defaults shown. Required fields are <code>serviceName</code>, <code>path</code> and an <code>events</code> array.</p>
<pre><code><span class="hljs-comment">// Watch file</span>

<span class="hljs-keyword">var</span> watcher = <span class="hljs-built_in">require</span>(<span class="hljs-string">'wsk'</span>).watcher;

<span class="hljs-comment">// This can be an object or an array of objects</span>
<span class="hljs-keyword">var</span> watchGroups = [
  {
    <span class="hljs-attr">serviceName</span>: <span class="hljs-string">'stylus'</span>, <span class="hljs-comment">// Give this watcher a name so we can use it to notify project creators what is happening</span>
    path: <span class="hljs-string">'src/css/**/*.styl'</span>, <span class="hljs-comment">// A glob or an array of globs</span>
    ignoreDotFiles: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Defaults to ignoring files that start with a `.`.</span>
    chokidarOptions: { <span class="hljs-comment">// Any options that can be passed to chokidar https://github.com/paulmillr/chokidar#api</span>
      ignoreInitial: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">warnIfMissingPath</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// By default, wsk will warn you (but proceed normally) if you have entered a non-glob path (or an array that contains a non-glob path) for a file that does not exist. This is because it's easy to get file paths wrong and it's nice to be told so. Sometimes, you will be watching a non-existent file by design. So, you can disable this warning by setting this to `false`.</span>
    displayOptions: {
      <span class="hljs-attr">hideAll</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Toggle the notification of what is being watched.</span>
      hideChildFiles: <span class="hljs-literal">false</span>, <span class="hljs-comment">// If path is a glob, toggle whether to show files in that glob</span>
      hideChildDirs: <span class="hljs-literal">false</span> <span class="hljs-comment">// If path is a glob, toggle whether to show directories in that glob</span>
      <span class="hljs-comment">// `hideAll` is different from setting both `hideChildFiles` and `hideChildDirs` are `true` because in the latter case, the bundle notification will still display.</span>
    },
    <span class="hljs-comment">// Specify an array of events that will be listened to and the files that will be run when those events occur. This array is empty by default.</span>
    <span class="hljs-comment">// Event types can be anything that chokidar supports: https://github.com/paulmillr/chokidar#methods--events</span>
    events: [
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'change'</span>,
        <span class="hljs-attr">taskFiles</span>: <span class="hljs-string">'path/to/stylus-build.js'</span>,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">myOption</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// You can pass an options object which will be the third argument to the task file's `onEvent` function.</span>
        }
      },
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'add'</span>,
        <span class="hljs-attr">taskFiles</span>: [<span class="hljs-string">'path/to/stylus-build.js'</span>, <span class="hljs-string">'path/to/other-task.js'</span>],
        <span class="hljs-attr">commands</span>: [<span class="hljs-string">'python path/to/python.py'</span>],
        <span class="hljs-attr">env</span>: {
          <span class="hljs-attr">myEnvVariable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// Same thing to `options` for task files except these get sent to `process.env` object.</span>
        }
      },
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'unlink'</span>,
        <span class="hljs-attr">taskFiles</span>: <span class="hljs-string">'path/to/stylus-build.js'</span>,
        <span class="hljs-attr">commands</span>: <span class="hljs-string">'npm run other-task'</span>
      }
    ]
  }
];

<span class="hljs-comment">// Add this watch group, will return an error or at list of the chokidar .getWatched() objects on done</span>
watcher.add(watchGroups, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, watchTrees</span>) </span>{
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// An array of directory tree objects for every watchGroup.</span>
  <span class="hljs-comment">// If you've passed an array of watchGroups, the callback happens after they are all done</span>
  <span class="hljs-built_in">console</span>.log(watchTree);
  <span class="hljs-comment">/*
  [{
    'src/css': [ 'styles.styl', 'embed.styl' ],
    'src/css/modules': [ 'colors.styl' ]
  }]
  */</span>
});
</code></pre>
<p><strong>Note:</strong> wsk uses <a href="https://npmjs.org/package/chokidar">chokidar</a> for its event watching, which <a href="https://github.com/paulmillr/chokidar#methods--events">supports</a> the following events:</p>
<blockquote>
<p><code>add</code>, <code>addDir</code>, <code>change</code>, <code>unlink</code>, <code>unlinkDir</code>, <code>ready</code>, <code>raw</code>, <code>error</code>. Additionally <code>all</code> is available which gets emitted with the underlying event name and path for every event other than <code>ready</code>, <code>raw</code>, and <code>error</code>.</p>
</blockquote>
</div><div class="scroll-section"><h4 id="specifying-a-targetfile-for-an-event"><a class="anchor-link" href="#specifying-a-targetfile-for-an-event">###</a> Specifying A <code>targetFile</code> For An Event</h4><p>Your event configurations can also specify replacement or additional files to be acted on. This can be useful if you want to delete a corresponding sourcemap if a CSS file is deleted, for example.</p>
<pre><code><span class="hljs-comment">// within the events array...</span>
{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'unlink'</span>,
  <span class="hljs-attr">taskFiles</span>: <span class="hljs-string">'path/to/unlink.js'</span>,
  <span class="hljs-comment">// this can also be a single string</span>
  targetFiles: [
    <span class="hljs-string">'public/css/styles.css'</span>,
    <span class="hljs-string">'public/css/styles.css.map'</span>
  ]
}

<span class="hljs-comment">// or give it a function that gets passed the file that triggered the event</span>

{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'unlink'</span>,
  <span class="hljs-attr">taskFiles</span>: <span class="hljs-string">'path/to/unlink.js'</span>,
  <span class="hljs-attr">targetFiles</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filePath</span>) </span>{
    <span class="hljs-comment">// filePath is the deleted file `src/css/filename.scss</span>
    <span class="hljs-keyword">var</span> outPath = filePath.replace(<span class="hljs-string">'src'</span>, <span class="hljs-string">'public'</span>).replace(<span class="hljs-string">'.scss'</span>, <span class="hljs-string">'.css'</span>)
    <span class="hljs-keyword">return</span> [
      outPath,
      outPath + <span class="hljs-string">'.map'</span>
    ] <span class="hljs-comment">// This can return a string or an array</span>
  }
}
</code></pre>
</div><div class="scroll-section"><h3 id="creating-a-task-file"><a class="anchor-link" href="#creating-a-task-file">##</a> Creating A Task File</h3><p>Here is a basic task file setup. Its <code>onEvent</code> function runs whenever the files specified in the watch file <code>path</code> glob has the specified action.</p>
<pre><code><span class="hljs-comment">// Task file</span>

<span class="hljs-comment">// Load our notification module</span>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> notify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'wsk'</span>).notify;

<span class="hljs-comment">// To run on an event specified in your watcher, it must export an `onEvent` function.</span>
<span class="hljs-comment">// This function gets passed three arguments:</span>
<span class="hljs-comment">// `eventType`, name of the event specified in your watch file</span>
<span class="hljs-comment">// `changedPath` is the path to the changed file or directory</span>
<span class="hljs-comment">// An optional `options` hash that comes from the watcher event specification.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onEvent</span> (<span class="hljs-params">eventType, changedPath, options</span>) </span>{
  <span class="hljs-comment">// Here write JavaScript API code for your target library</span>
  <span class="hljs-comment">// to transform the changed file...</span>
  myRenderLib(changedPath, (err, code) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-comment">// Log out what we're doing to the user</span>
      notify({
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Error converting file to foo format...'</span>,
        <span class="hljs-attr">value</span>: changedPath,
        <span class="hljs-attr">display</span>: <span class="hljs-string">'error'</span>,
        <span class="hljs-attr">error</span>: err
      });
    } <span class="hljs-keyword">else</span> {
      notify({
        <span class="hljs-attr">message</span>: <span class="hljs-string">'We did something to this file:'</span>,
        <span class="hljs-attr">value</span>: changedPath,
        <span class="hljs-attr">display</span>: <span class="hljs-string">'compile'</span>
      });
      <span class="hljs-comment">// Write out the file</span>
      <span class="hljs-keyword">var</span> outPath = changedPath.replace(<span class="hljs-string">'src'</span>, <span class="hljs-string">'public'</span>);
      fs.writeFileSync(outPath, code);
    }
  });
}

<span class="hljs-comment">// Export a public function called `onEvent`, which is what watcher expects</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">onEvent</span>: onEvent
};
</code></pre>
<p>See the <a href="https://github.com/bloomberg/wsk.example/tree/master/build/tasks">wsk example project</a> for production examples.</p>
</div><div class="scroll-section"><h3 id="packagejson-setup"><a class="anchor-link" href="#packagejson-setup">##</a> Package.json Setup</h3><p>In this pattern, you run your watch files with an npm command such as <code>npm run dev</code> and build your project with <code>npm run build</code>. You can configure your scripts however you like but these docs will discuss the conventions in our example.</p>
<p>Each dev command starts with <code>dev:</code> and points to watcher files. Build commands start with <code>build:</code> and point to build task files. We add a <code>predev</code> tasks that builds your files every time you start up the dev process.</p>
<pre><code>{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"dev:css"</span>: <span class="hljs-string">"node build/tasks/watch-css.js"</span>,
    <span class="hljs-attr">"dev:js"</span>: <span class="hljs-string">"node build/tasks/watch-js.js"</span>,
    <span class="hljs-attr">"dev:html"</span>: <span class="hljs-string">"node build/tasks/watch-html.js"</span>,
    <span class="hljs-attr">"build:css"</span>: <span class="hljs-string">"node build/tasks/build-css.js"</span>,
    <span class="hljs-attr">"build:js"</span>: <span class="hljs-string">"node build/tasks/build-js.js"</span>,
    <span class="hljs-attr">"build:html"</span>: <span class="hljs-string">"node build/tasks/build-html.js"</span>,
    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"npm run dev:css --silent &amp;&amp; npm run dev:js --silent &amp;&amp; npm run dev:html --silent"</span>,
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"npm run build:css --silent &amp;&amp; npm run build:js --silent &amp;&amp; npm run build:html --silent"</span>,
    <span class="hljs-attr">"predev"</span>: <span class="hljs-string">"npm run build --silent"</span>
  }
}
</code></pre>
<p><strong>Note:</strong> The <code>--silent</code> flag is optional but including it will make your console output more readable and easier to follow along with. It supresses boilerplate npm output.</p>
</div><div class="scroll-section"><h3 id="notifying-users"><a class="anchor-link" href="#notifying-users">##</a> Notifying Users</h3><p>wsk uses the <a href="https://github.com/bloomberg/wsk-notify">wsk-notify</a> library to handle styling. One cool thing to point out is that errors appear as desktop notifications, which is very helpful.</p>
<p>You can take a look at <a href="https://bloomberg.github.io/wsk-notify">the wsk-notify documentation</a> for full options and styles. The basic usage is as follows:</p>
<pre><code><span class="hljs-keyword">var</span> notify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'wsk'</span>).notify;

notify({
  <span class="hljs-attr">message</span>: <span class="hljs-string">'My message...'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'value'</span>,
  <span class="hljs-attr">display</span>: <span class="hljs-string">'compile'</span> <span class="hljs-comment">// Can be any of the following: 'add', 'change', 'compile', 'error', 'reload', 'remove', 'serve', 'success', 'watch' or 'warn'</span>
});
</code></pre>
<p>The basic compile display style looks like this:</p>
<p><img src="img/compile.png" alt="compile display"></p>
<p>Here what <code>npm run build</code> gives you:</p>
<p><img src="img/build.png" alt="wsk build example"></p>
<p>And here is what <code>npm run dev</code> gives you:</p>
<p><img src="img/dev.png" alt="wsk watch example"></p>
</div><div class="scroll-section"><h2 id="roadmap"><a class="anchor-link" href="#roadmap">#</a> Roadmap</h2><p>Here are features that we would like to integrate into future versions of wsk.</p>
<ol>
<li>Dependency tree creation. It would be nice if the user could supply a function that defines a way to find dependency in a given file. This could be either by getting passed an AST or through simple string matching. For example, if you always read templates through a <code>h.readTemplate</code> function, you could extract those files recursively.</li>
<li>Pass in a clock object or timestamp to a taskfile for easy timing.</li>
<li>Set up a &quot;Resolved&quot; notification style so you can know that your error was fixed via desktop notification.</li>
</ol>
</div><div class="scroll-section"><h2 id="contributors"><a class="anchor-link" href="#contributors">#</a> Contributors</h2><ul>
<li><a href="https://twitter.com/mhkeller">Michael Keller</a></li>
<li><a href="https://twitter.com/_jsdiamond">Jeremy Diamond</a></li>
<li><a href="https://twitter.com/blackili">Blacki Migliozzi</a></li>
</ul>
</div><div class="scroll-section"><h2 id="license"><a class="anchor-link" href="#license">#</a> License</h2><p>Apache-2.0</p>
</div>
      </div>
    </div>

    <div id="sidebar-button" class="mnav" data-open="false">
      <div class="nav-logo wsk-logo"></div>
      <button class="sidebar-btn"></button>
    </div>

    <div id="sidebar-button-target" class="sidebar" data-open="false">
      <div class="home-key">
        <a href="#">
          <div class="main-logo wsk-logo"></div>
          <div class="wsk-logo-text">wsk</div>
        </a>
      </div>

      
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#about">About</a><ul>
<li><a href="#built-in-functionality">Built-in Functionality</a></li>
<li><a href="#architecture">Architecture</a></li>
</ul>
</li>
<li><a href="#faq">FAQ</a><ul>
<li><a href="#how-is-it-different">How is it different?</a></li>
<li><a href="#what-are-the-advantages">What are the advantages?</a></li>
<li><a href="#why-not-gulp">Why not Gulp?</a></li>
<li><a href="#arent-streams-useful-though">Aren&#39;t streams useful, though?</a></li>
<li><a href="#but-isnt-it-faster-to-load-a-file-with-a-stream">But isn&#39;t it faster to load a file with a stream?</a></li>
<li><a href="#how-are-task-files-different-from-plugins">How are task files different from plugins?</a></li>
<li><a href="#why-not-webpack">Why not Webpack?</a></li>
<li><a href="#why-not-command-line-libraries-in-npm-scripts">Why not command-line libraries in npm scripts?</a></li>
<li><a href="#how-did-you-design-wsk">How did you design wsk?</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#creating-a-watch-file">Creating A Watch File</a><ul>
<li><a href="#specifying-a-targetfile-for-an-event">Specifying A targetFile For An Event</a></li>
</ul>
</li>
<li><a href="#creating-a-task-file">Creating A Task File</a></li>
<li><a href="#packagejson-setup">Package.json Setup</a></li>
<li><a href="#notifying-users">Notifying Users</a></li>
</ul>
</li>
<li><a href="#roadmap">Roadmap</a></li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#license">License</a></li>
</ul>


      <div class="alt-home-key">
        <a href="https://bloomberg.github.io/wsk-notify">
          <div class="sub-logo wsk-notify-logo"></div>
          <div class="sub-logo-text">wsk-notify</div>
        </a>
      </div>

    </div>
  </main>

  <script src="js/main.pkgd.js"></script>

  </body>
</html>
